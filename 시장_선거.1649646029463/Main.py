n = int(input())
A = list(map(int, input().split()))
B = [0 for i in range(n)] #투표 결과를 저장할 리스트
limit = n/2

for i in range(n): #
    temp = A[i]
    B[temp-1] += 1  #리스트 A를 돌면서 후보들이 받은 투표수를 업데이트 

max_num = max(B)  #리스트 B에는 투표 결과가 저장되어있고 이 중 최댓값을 찾는다.

if max_num <= limit:  #최댓값이 반보다 많은 지지를 받지 못한 경우
    print(-1)
else:  #최댓값이 반보다 많은 지지를 받은 경우 index 메소드를 통해 후보자의 번호 return 
    print(B.index(max_num)+1)

		
		
		
#자료 구조 및 해결 방법 : B라는 새로운 리스트를 사용하여 투표 결과를 저장하는 용도로 사용하였다. B의 인덱스는 (후보자의 번호 -1)을 의미하고 인덱스가 가리키는 값은 후보자가 받은 투표수를 나타낸다. 이렇게 취합한 결과 중 최댓값은 가장 많은 표를 받은 득표자를 가리키므로 이 득표자가 반 이상의 지지를 받았는지를 비교하고 그렇다면 해당 후보자의 번호, 그렇지 않다면 -1을 return해준다. 

# 시간복잡도 : 첫번 째 for문은 A의 원소 개수만큼 돌아가기 때문에 O(n)이 걸리고 이후 max() 함수를 사용했기에 O(n)이 추가로 걸린다. 뒤에 나오는 if, else문 내에 index() 함수는 O(1)의 시간이 소요되므로 총 걸린 수행시간은 O(2n) -> O(n)이다. 